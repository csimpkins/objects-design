\documentclass{beamer}

\newcommand{\course}{CS 2340 Objects and Design}
\newcommand{\lesson}{Software Engineering}
\newcommand{\code}{http://www.cc.gatech.edu/~simpkins/teaching/gatech/cs2340/code}

\author[Chris Simpkins] 
{Christopher Simpkins \\\texttt{chris.simpkins@gatech.edu}}
\institute[Georgia Tech] % (optional, but mostly needed)

\date[CS 1331]{}

\include{beamer-common}

% \beamerdefaultoverlayspecification{<+->}


\begin{document}

\begin{frame}
  \titlepage
\end{frame}



%------------------------------------------------------------------------
\begin{frame}[fragile]{Software Engineering}


Definition 3.2760 from ISO/IEC/IEEE 24765:2010(E)
\begin{enumerate}
\item the systematic application of scientific and technological knowledge, methods, and experience to the design, implementation, testing, and documentation of software. ISO/IEC 2382-1:1993, Information technology -- Vocabulary -- Part 1: Fundamental terms.01.04.07.
\item the application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software.
\end{enumerate}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{The Definition Expanded}


the systematic application of ... methods ... [and]disciplined, quantifiable approach to the development, operation, and maintenance of software
\begin{itemize}
\item Software development development life cycle
\item Software development process models
\end{itemize}

application of scientific and technological knowledge
\begin{itemize}
\item Software design principles
\item Programming languages
\item Software development tools
\end{itemize}

the systematic application of ... experience
\begin{itemize}
\item Process improvement frameworks
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Software Development Life Cycle}


All software development projects go through identifiable phases:
\begin{itemize}
\item Planning
\item Requirements Analysis
\item Design
\item Implementation
\item Integration
\item Testing
\item Deployment
\item Maintenance
\end{itemize}
Process models differ in how they approach these phases and organize them into a complete software development project

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Planning and Requirements Analysis}


\begin{itemize}
\item Planning
\begin{itemize}
\item Identify the need for a software system
\item Allocate resources (people, budget, equipment)
\item Set a timeline for development
\end{itemize}
\item Requirements Analysis
\begin{itemize}
\item Identify the users and other stakeholders of the system
\item Elicit requirements from the stakeholders: features, performance characteristics, usability requirements
\end{itemize}
\end{itemize}
Requirements and planning usually interleaved - requirements drive timelines, resources constrain requirements

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Design and Implementation}


Design: how the software will be structured to meet the requirements
\begin{itemize}
\item High-level architecture, e.g., client-server, desktop application, web application
\item Component design using object-oriented design, entity-relationship modeling, etc
\end{itemize}

Implementation: writing the code to realize the design in a working system
\begin{itemize}
\item Programming
\item Building
\item Art and UI (icons, style sheets, dialog layouts, etc)
\end{itemize}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Integration and Testing}


Integration: putting the components together
\begin{itemize}
\item Make sure software components work together
\item Make sure software integrates with host operating system
\end{itemize}

Testing: verifying that the software works as expected
\begin{itemize}
\item Some tests done by developers (unit tests, some functional tests)
\item Some tests done by quality assurance engineers and customer (functional tests, acceptance tests)
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Deployment and Maintenance}


Deployment: putting the software in the hands of its users
\begin{itemize}
\item How to deploy
\end{itemize}

Maintenance: fixing bugs and adding enhancements or new features after the software has been deployed
\begin{itemize}
\item Enhancements and bug fixes for current release
\item Development of new version
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Software Development Process Models}


\begin{columns}[c]
\begin{column}{1.8in}
\begin{center}
\includegraphics[width=2.2in]{waterfall.png}
\end{center}
\end{column}
\begin{column}{3.1in}
\begin{itemize}
\item Two stereotypical process models: waterfall and iterative
\item Waterfall processes, a.k.a. sequential processes, finish each phase of the SDLC before moving on to the next
\begin{itemize}
\item Sometimes called ``big bang'' development, since in classic waterfall the system under development is not released until the end of the project
\item Incremental waterfall processes include intermediate releases in the implementation phase
\end{itemize}
\end{itemize}
\end{column}
\end{columns}
\footnote{Source: http://en.wikipedia.org/wiki/File:Waterfall\_model\_(1).svg}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Iterative Development}

\begin{columns}[c]
\begin{column}{2.8in}
\begin{center}
\includegraphics[width=2.8in]{spiral.png}
\end{center}
\end{column}
\begin{column}{2in}
\begin{itemize}
\item Divide the project into short (typically two-week) iterations
\item Each iteration progresses through each of the SDLC phases
\begin{itemize}
\item Each iteration accomplishes a subset of the requirements and releases a working product
\end{itemize}
\end{itemize}
\end{column}
\end{columns}
\footnote{Source: http://en.wikipedia.org/wiki/File:Spiral\_model\_(Boehm,\_1988).svg}

\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Rational Unified Process}


\begin{itemize}
\item Developed by Rational Software and acquired by IBM in 2003
\item Unifies waterfall and iterative process models with four life-cycle phases:
\begin{itemize}
\item Inception: feasibility - vision, scope, rough estimates
\item Elaboration: most requirements, more detailed estimates, implementation of core architecture and highest risk features
\item Construction: implementation of remaining features, iterative refinement of requirements and estimates
\item Transition: beta tests, deployment
\end{itemize}
\end{itemize}
\begin{center}
\includegraphics[height=1.5in]{rup-iterations.png}
\end{center}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Software Design Science}

\begin{quote}
Programs = data structures + algorithms
\end{quote}
What software engineers learn in school
\begin{itemize}
\item Computer science
\begin{itemize}
\item Data structures and algorithms
\item Programming languages
\item Object-oriented programming, Functional programming
\item Systems, networks, HCI, AI (threads)
\end{itemize}
\item Software design and implementation
\begin{itemize}
\item Design patterns
\item Modeling approaches and languages (like UML)
\item Programming
\end{itemize}
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Software Development Practice}


\begin{itemize}
\item Programming tools
\begin{itemize}
\item Editors, debuggers, profilers
\end{itemize}
\item Build tools
\begin{itemize}
\item Make, SCons, Ant, Maven, SBT, Gradle, Buildr, Rake
\end{itemize}
\item Integration tools
\begin{itemize}
\item Test runners, installer software, continuous integration servers
\end{itemize}
\item Deployment and maintenance tools
\begin{itemize}
\item Software configuration management (CVS, Subversion, Git)
\item Bug trackers (Bugzilla, Trac, GitHub)
\end{itemize}

\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{ISO 9001}


\begin{itemize}
\item A generic quality management standard with a process-based management approach
\item International standard based on british standard dating back to 1987 (current version is 2000)
\item Adopted by many industries: aviation, automotive, software
\item Based on 8 quality principles from ISO 9000:
\begin{itemize}
\item Customer focus
\item Leadership
\item Involvement of people
\item Process approach
\item System approach to management
\item Continual improvement
\item Factual approach to decision making
\item Mutually beneficial supplier relationships
\end{itemize}
\item Doesn't specify the process; can meet ISO 9001 with RUP/XP/Scrum/Homegrown Process
\item Some customers will want or require ISO 9001 certification
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Capability Maturity Model (CMM/CMMI)}


\begin{itemize}
\item Developed by Carnegie Mellon's Software Engineering Institute - originally for software engineering, now generically covers acquisition development, and services (and people)
\item Models include goals, practices organized into practice areas
\item Appraisals grade organizations for capability levels (0 through 3) in each process area, and maturity levels (1 through 5)
\item CMMI documented in zillions of pages of <sarcasm>engagingly written documents and books.  Consult them if you're fortunate enough to be implementing CMMI.</sarcasm>
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

%------------------------------------------------------------------------
\begin{frame}[fragile]{Conclusion}


The engineering of software encompasses process and practice
\begin{itemize}
\item Process - documentation, project management
\item Practice - software architecture, design, implementation, tools and technologies
\end{itemize}


\end{frame}
%------------------------------------------------------------------------

% %------------------------------------------------------------------------
% \begin{frame}[fragile]{}


% \begin{lstlisting}[language=Java]

% \end{lstlisting}

% \begin{itemize}
% \item
% \end{itemize}


% \end{frame}
% %------------------------------------------------------------------------


\end{document}
